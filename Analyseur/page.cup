package compiler;

import Instruction.Node;
import Instruction.Order;
import Instruction.DataType;
import Instruction.Operator;
import Instruction.JoinType;

parser code {:

   public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
		m.append (info.toString());
        m.append(" : "+message);
        System.err.println(m.toString());
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

	private SQLContext context;
    public void setContext (SQLContext context) {
    	this.context = context;
    }

    public SQLContext getContext () {
		return context;
    }

	public SQLFactory getFactory () {
		return getContext().getFactory();
	}

:}

terminal TERM, SEP, POINT;
terminal SELECT, FROM, WHERE, CREATE, TABLE, DELETE, UPDATE, SET, PRIMARY, KEY, INSERT, INTO, VALUES;
terminal Long INTEGER;
terminal Double DOUBLE;
terminal String ID;
terminal String	TEXT;
terminal OPEN_PARENTHESIS, CLOSE_PARENTHESIS;
terminal NOT, NULL;
terminal INT, VARCHAR, BIGINT, BIT, TINYINT, SMALLINT, NUMERIC, FLOAT, REAL, MONEY, DECIMAL, DATE, TIME, CHAR;
terminal ORDER, GROUP, BY, ASC, DESC;
terminal DROP;
terminal OR, AND;
terminal NOT_EQ, EQUAL, LESS, GREATER, LESS_OR_EQ, GREATER_OR_EQ;
terminal CONCAT;
terminal PLUS, MINUS, MULT, DIV;
terminal TRUE, FALSE;
terminal NULLS, FIRST, LAST;
terminal INNER, CROSS, LEFT, RIGHT, FULL, SELF, NATURAL, UNION;
terminal JOIN;
terminal ON;
terminal USING;
terminal AS;

nonterminal Node	Commandes, Instruction, Instructions;
nonterminal Node 	Expression, Expressions;
nonterminal Node	Columns, Column;
nonterminal Node	TableExpression;
nonterminal Node	WhereOpt, Where;
nonterminal Node	GroupByOpt, GroupBy;
nonterminal Node	OrderByOpt, OrderBy, Order, OrderExpressions, OrderExpression, OrderOpt;
nonterminal Node	NullsOpt, Nulls;
nonterminal Node	Set, Sets;
nonterminal Node	Datas, Data, DataType, NotOpt, NullOpt;
nonterminal Node	Value, Numeric;
nonterminal Node	PrimaryKeyOpt, PrimaryKey;
nonterminal Node	AndCondition, Condition, Operand, Summand, Compare, Factor, Term, Terms;
nonterminal Node	SelectExpression, SelectExpressions;
nonterminal Node	Number;
nonterminal Node	Function;
nonterminal Node	JoinOpt;
nonterminal Node	Join;
nonterminal Node	JoinSpecification;
nonterminal Node	ColumnName, TableAlias, SchemaName;
nonterminal Node	As, AsOpt;
nonterminal Node	ColumnAlias;
nonterminal Node	SelectInstruction, Select;
nonterminal Node	From;

nonterminal JoinType	JoinType;

precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left AND, OR;
precedence right NOT;

Commandes	::= Instructions
			|	Expression
         	;

Instructions	::=
            	|	Instructions Instruction:i TERM	{: getContext().addInstruction(i); :}
            	;

Instruction ::=	CREATE TABLE TableExpression:t OPEN_PARENTHESIS Datas:d PrimaryKeyOpt:p CLOSE_PARENTHESIS
				{:
					RESULT = getFactory().createNodeCreate(t, d, p);
				:}
			|	DELETE FROM TableExpression:t WhereOpt:w	{: RESULT = getFactory().createNodeDelete(t, w); :}
			|	UPDATE TableExpression:t SET Sets:s WhereOpt:w	{: RESULT = getFactory().createNodeUpdate(t, s, w); :}
			|	INSERT INTO TableExpression:t OPEN_PARENTHESIS Columns:cols CLOSE_PARENTHESIS VALUES OPEN_PARENTHESIS Terms:ts CLOSE_PARENTHESIS
				{:
					RESULT = getFactory().createNodeInsert(t, cols, ts);
				:}
			|	DROP TABLE TableExpression:t
				{:
					RESULT = getFactory().createNodeDrop(t);
				:}
			|	SelectInstruction:s	{: RESULT = s; :}
			;

SelectInstruction	::=	SELECT Select:s FROM From:f WhereOpt:w GroupByOpt:g OrderByOpt:o
						{:
							RESULT = getFactory().createNodeSelect(s, f, w, g, o);
						:}
					;
					
Select	::=	MULT /* hack: wildcard */	{: RESULT = getFactory().createNodeSelectExpression(getFactory().createNodeWildcard(), null); :}
		|	SelectExpressions:es		{: RESULT = es; :}
		;
		
From	::=	TableExpression:t	{: RESULT = getFactory().createNodeFrom(t); :}
		;
			
SelectExpressions	::=	SelectExpression:e	{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(e); :}
					|	SelectExpressions:es SEP SelectExpression:e
						{:
							RESULT = es;
							es.getChildren().add(e);
						:}
					;
			
SelectExpression	::=	Expression:e AsOpt:a	{: RESULT = getFactory().createNodeSelectExpression(e, a); :}
					|	Function:f	{: RESULT = f; :}
					;
					
AsOpt	::=	
		|	As:a	{: RESULT = a; :}
		;
		
As	::=	AS ColumnAlias:alias	{: RESULT = getFactory().createNodeAs(alias); :}
	;
	
ColumnAlias	::=	ID:name	{: RESULT = getFactory().createNodeColumnAlias(getFactory().createNodeText(name)); :}
			;

Function	::= ID:name OPEN_PARENTHESIS Column:c CLOSE_PARENTHESIS {: RESULT = getFactory().createNodeFunction(name); RESULT.getChildren().add(c); :}
			;
			
Columns	::= Column:n				{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(n); :}
     	|	Columns:ns SEP Column:n	{: RESULT = ns; ns.getChildren().add(n); :}
     	;

Column	::=	ColumnName:name	{: RESULT = getFactory().createNodeColumn(name); :}
		|	TableAlias:alias POINT ColumnName:name	{: RESULT = getFactory().createNodeColumn(alias, name); :}
// shift/reduce		|	SchemaName:schema POINT TableAlias:alias POINT ColumnName:name	{: RESULT = getFactory().createNodeColumn(schema, alias, name); :}
    	;
    	
ColumnName	::=	ID:name	{: RESULT = getFactory().createNodeColumnName(getFactory().createNodeText(name)); :}
			;
			

TableAlias	::=	ID:alias	{: RESULT = getFactory().createNodeTableAlias(getFactory().createNodeText(alias)); :}
			;

/*			
SchemaName	::=	ID:name	{: RESULT = getFactory().createNodeSchemaName(getFactory().createNodeText(name)); :}
			;
*/

TableExpression	::=	ID:name JoinOpt:j  {: RESULT = getFactory().createNodeTableExpression(name, j); :}
     			;
     			
JoinOpt		::=	
			|	Join:j	{: RESULT = j; :}
			;
			
Join		::= JoinType:t JOIN TableExpression:e JoinSpecification:s	{: RESULT = getFactory().createNodeJoin(t, e, s); :}
			;

JoinType	::=	
			|	INNER	{: RESULT = JoinType.INNER; :}
			|	CROSS	{: RESULT = JoinType.CROSS; :}
			|	LEFT	{: RESULT = JoinType.LEFT; :}
			|	RIGHT	{: RESULT = JoinType.RIGHT; :}
			|	FULL	{: RESULT = JoinType.FULL; :}
			|	SELF	{: RESULT = JoinType.SELF; :}
			|	NATURAL	{: RESULT = JoinType.NATURAL; :}
			|	UNION	{: RESULT = JoinType.UNION; :}
			;
			
JoinSpecification	::=	ON Expression:e	{: RESULT = getFactory().createNodeOn(e); :}
					|	USING OPEN_PARENTHESIS Columns:cs CLOSE_PARENTHESIS	{: RESULT = getFactory().createNodeUsing(cs); :}
					;

WhereOpt	::=
        	|	Where:w	{: RESULT = w; :}
        	;

Where	::=	WHERE Expression:c	{: RESULT = getFactory().createNodeWhere(c); :}
     	;

GroupByOpt	::=
			| GroupBy:g	{: RESULT = g; :}
			;

GroupBy ::= GROUP BY Expressions:es	{: RESULT = getFactory().createNodeGroup(es); :}
		;

OrderByOpt	::=
			| OrderBy:o	{: RESULT = o; :}
			;

OrderBy ::= ORDER BY OrderExpressions:os	{: RESULT = os; :}
		;

OrderExpressions	::=	OrderExpression:o	{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(o); :}
					|	OrderExpressions:os SEP OrderExpression:o	{: RESULT = os; os.getChildren().add(o); :}
					;
		
OrderExpression	::=	Expression:e OrderOpt:o NullsOpt:n	{: RESULT = getFactory().createNodeOrderExpression(e, o, n); :}
				;

OrderOpt	::=	
			|	Order:o	{: RESULT = o; :}
			;

Order	::=	ASC		{: RESULT = getFactory().createNodeOrder(Order.ASC); :}
		|	DESC	{: RESULT = getFactory().createNodeOrder(Order.DESC); :}
		;
		
NullsOpt	::=	
			|	Nulls:n	{: RESULT = n; :}
			;
			
Nulls	::=	NULLS FIRST
		|	NULLS LAST
		;
		
Expressions	::=	Expression:e	{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(e); :}
			|	Expressions:es SEP Expression:e	{: RESULT = es; es.getChildren().add(e); :}
			;

Expression	::=	AndCondition:c					{: RESULT = c; :}
			|	Expression:e OR AndCondition:c
				{:
					RESULT = getFactory().createNodeOperator(Operator.OR);
					RESULT.getChildren().add(e);
					RESULT.getChildren().add(c);
				:}
         	;

AndCondition	::=	Condition:c						{: RESULT = c; :}
				|	AndCondition:e AND Condition:c
					{:
						RESULT = getFactory().createNodeOperator(Operator.AND);
						RESULT.getChildren().add(e);
						RESULT.getChildren().add(c);
					:}
         		;

Condition	::=	Operand:o	{: RESULT = o; :}
			|	Operand:o1 Compare:cmp Operand:o2
				{:
					RESULT = cmp;
					cmp.getChildren().add(o1);
					cmp.getChildren().add(o2);
				:}
			|	NOT Expression:e	{: RESULT = getFactory().createNodeNot(); RESULT.getChildren().add(e); :}
			|	OPEN_PARENTHESIS Expression:e CLOSE_PARENTHESIS	{: RESULT = e; :}
			;

Compare	::=	NOT_EQ			{: RESULT = getFactory().createNodeOperator(Operator.NOT_EQ); :}
		|	EQUAL			{: RESULT = getFactory().createNodeOperator(Operator.EQUAL); :}
		|	LESS_OR_EQ		{: RESULT = getFactory().createNodeOperator(Operator.LESS_OR_EQ); :}
		|	GREATER_OR_EQ	{: RESULT = getFactory().createNodeOperator(Operator.GREATER_OR_EQ); :}
		|	LESS			{: RESULT = getFactory().createNodeOperator(Operator.LESS); :}
		|	GREATER			{: RESULT = getFactory().createNodeOperator(Operator.GREATER); :}
		;

Operand	::=	Summand:s					{: RESULT = s; :}
		|	Operand:o CONCAT Summand:s	{: RESULT = getFactory().createNodeConcat(o, s); :}
		;

Summand	::=	Factor:f					{: RESULT = f; :}
		|	Summand:s PLUS Factor:f		{: RESULT = getFactory().createNodePlus(s, f); :}
		|	Summand:s MINUS Factor:f	{: RESULT = getFactory().createNodeMinus(s, f); :}
		;

Factor	::=	Term:t					{: RESULT = t; :}
		|	Factor:f MULT Term:t	{: RESULT = getFactory().createNodeMult(f, t); :}
		|	Factor:f DIV Term:t		{: RESULT = getFactory().createNodeDiv(f, t); :}
		;
		
Terms	::=	Term:t	{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(t); :}
		|	Terms:ts SEP Term:t	{: RESULT = ts; ts.getChildren().add(t); :}
		;

Term	::= Value:v		{: RESULT = v; :}
		|	Column:c	{: RESULT = c; :}
		;
		
Sets	::=	Set:s	{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(s); :}
		|	Sets:ss SEP Set:s	{: RESULT = ss; ss.getChildren().add(s); :}
		;

Set		::= Column:c EQUAL Expression:e	{: RESULT = getFactory().createNodeSet(c, e); :}
		;

Datas	::= Data:d				{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(d); :}
     	|	Datas:ds SEP Data:d	{: RESULT = ds; ds.getChildren().add(d); :}
     	;

Data	::=	Column:c DataType:t NullOpt:e	{: RESULT = getFactory().createNodeData(c, t, e); :}
    	;


Type 	::= INT			{: RESULT = getFactory().createNodeType(DataType.INT); :}
		| 	SMALLINT	{: RESULT = getFactory().createNodeType(DataType.SMALLINT); :}
		| 	TINYINT		{: RESULT = getFactory().createNodeType(DataType.TINYINT); :}
		| 	BIGINT		{: RESULT = getFactory().createNodeType(DataType.BIGINT); :}
		| 	FLOAT		{: RESULT = getFactory().createNodeType(DataType.FLOAT); :}
		| 	REAL		{: RESULT = getFactory().createNodeType(DataType.REAL); :}
		| 	MONEY		{: RESULT = getFactory().createNodeType(DataType.MONEY); :}
		| 	DATE		{: RESULT = getFactory().createNodeType(DataType.DATE); :}
		| 	TIME		{: RESULT = getFactory().createNodeType(DataType.TIME); :}
		| 	BIT			{: RESULT = getFactory().createNodeType(DataType.BIT); :}
		| 	CHAR OPEN_PARENTHESIS INTEGER:n CLOSE_PARENTHESIS		{: RESULT = getFactory().createNodeType(DataType.CHAR,n); :}
		|	VARCHAR OPEN_PARENTHESIS INTEGER:n CLOSE_PARENTHESIS	{: RESULT = getFactory().createNodeType(DataType.VARCHAR, n); :}
		;

NullOpt	::=
		|	NotOpt:n NULL
		{:
			if (n == null) {
				RESULT = getFactory().createNodeNull();
			} else {
				RESULT = n;
				n.getChildren().add(getFactory().createNodeNull());
			}
		:}
		;

NotOpt	::=
		|	NOT	{: RESULT = getFactory().createNodeNot(); :}
		;

Value	::= TEXT:t		{: RESULT = getFactory().createNodeText(t); :}
		|	Numeric:n	{: RESULT = n; :}
		|	TRUE		{: RESULT = getFactory().createNodeBoolean(true); :}
		|	FALSE		{: RESULT = getFactory().createNodeBoolean(false); :}
		|	NULL		{: RESULT = getFactory().createNodeNull(); :}
		;

Numeric	::=	Number:n		{: RESULT = n; :}
		|	MINUS Number:n	{: RESULT = getFactory().createNodeUminus(); RESULT.getChildren().add(n); :}
		;

PrimaryKeyOpt	::=
				|	PrimaryKey:k	{: RESULT = k; :}
				;

PrimaryKey	::=	SEP PRIMARY KEY OPEN_PARENTHESIS Column:n CLOSE_PARENTHESIS
				{:
					RESULT = getFactory().createNodePrimaryKey(n);
				:}
			;

Number	::=	INTEGER:n	{: RESULT = getFactory().createNodeInteger(n); :}
		|	DOUBLE:n	{: RESULT = getFactory().createNodeDouble(n); :}
		;
