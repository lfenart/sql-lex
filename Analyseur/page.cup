package compiler;

import ui.Node;

parser code {:

   public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
		m.append (info.toString());
        m.append(" : "+message);
        System.err.println(m.toString());
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

	private SQLContext context;
    public void setContext (SQLContext context) {
    	this.context = context;
    }

    public SQLContext getContext () {
		return context;
    }

	public SQLFactory getFactory () {
		return getContext().getFactory();
	}

:}

terminal TERM, SEP;
terminal SELECT, SELECT_ALL, FROM, WHERE, CREATE, TABLE, DELETE, UPDATE, SET, PRIMARY, KEY, INSERT, INTO, VALUES;
terminal Integer NUMBER;
terminal String ID;
terminal String	TEXT;
terminal OPEN_PARENTHESIS, CLOSE_PARENTHESIS, QUOTE;
terminal NOT, NULL;
terminal INT, VARCHAR;
terminal WILDCARD;
terminal ORDER, GROUP, BY, ASC, DESC;
terminal DROP;
terminal OR, AND;
terminal NOT_EQ, EQUAL, LESS, GREATER, LESS_OR_EQ, GREATER_OR_EQ;
terminal CONCAT;
terminal PLUS, MINUS, MULT, DIV;
terminal TRUE, FALSE;
terminal DOT;

nonterminal Node	Commandes, Instruction, Instructions;
nonterminal Node 	Expression;
nonterminal Node	Columns, Column;
nonterminal Node	Table;
nonterminal Node	WhereOpt, Where;
nonterminal Node	GroupByOpt, GroupBy;
nonterminal Node	OrderByOpt, OrderBy, Order, OrderOpt;
nonterminal Node	Set;
nonterminal Node	Datas, Data, Type, NotOpt, NullOpt;
nonterminal Node	Values, Value, Numeric;
nonterminal Node	PrimaryKeyOpt;
nonterminal Node	AndCondition, OrCondition, Condition, Operand, Summand, Compare, Factor, Term;
nonterminal Node	UminusOpt;


Commandes	::= Instructions 
         	;

Instructions	::=
            	|	Instructions:l Instruction:i TERM	{: getContext().addInstruction(i); :}
            	;

Instruction ::=	CREATE TABLE Table:t OPEN_PARENTHESIS Datas:d PrimaryKeyOpt:p CLOSE_PARENTHESIS
				{:
					RESULT = getFactory().createNodeCreate(t, d, p);
				:}
			|	DELETE FROM Table:t WhereOpt:w	{: RESULT = getFactory().createNodeDelete(t, w); :}
			|	UPDATE Table:t Set:s WhereOpt:w	{: RESULT = getFactory().createNodeUpdate(t, w); :}
			|	INSERT INTO Table:t OPEN_PARENTHESIS Columns:cols CLOSE_PARENTHESIS VALUES OPEN_PARENTHESIS Values:vs CLOSE_PARENTHESIS
				{:
					RESULT = getFactory().createNodeInsert(cols, vs);
				:}
			|	SELECT Columns:cols FROM Table:t WhereOpt:w GroupByOpt:g OrderByOpt:o
				{:
					RESULT = getFactory().createNodeSelect(cols, t, w, g, o);
				:}
			|	SELECT_ALL FROM Table:t WhereOpt:w GroupByOpt:g OrderByOpt:o
				{:
					RESULT = getFactory().createNodeSelect(null /* fix? */, t, w, g, o);
				:}
			|	DROP TABLE Table:t
				{:
					RESULT = getFactory().createNodeDrop(t);
				:}
			;

Columns	::= Column:n				{: RESULT = getFactory().createNodeColumns(); RESULT.addChild(n); :}
     	|	Columns:ns SEP Column:n	{: RESULT = ns; ns.addChild(n); :}
     	;

Column	::=	ID:name	{: RESULT = getFactory().createNodeColumn(name); :}
    	;

Table	::=	ID:name	{: RESULT = getFactory().createNodeTable(name); :}
     	;

PrimaryKey ::=
			|	SEP PRIMARY KEY OPEN_PARENTHESIS Column:n CLOSE_PARENTHESIS
				{:
					RESULT = getFactory().createNodePrimaryKey(n);
				:}
			;

WhereOpt	::=
        	|	Where:w	{: RESULT = w; :}
        	;

Where	::=	WHERE Expression:c	{: RESULT = getFactory().createNodeWhere(c); :}
     	;

GroupByOpt	::=
			| GroupBy:g	{: RESULT = g; :}
			;

GroupBy ::= GROUP BY Column:c	{: RESULT = getFactory().createNodeGroupBy(c); :}
		;

OrderByOpt	::=
			| OrderBy:o	{: RESULT = o; :}
			;

OrderBy ::= ORDER BY Column:c OrderOpt:o	{: RESULT = getFactory().createNodeOrderBy(c, o); :}
		;

OrderOpt	::=
			|	Order:o	{: RESULT = o; :}
			;

/* enum Order { ASC, DESC } */
Order	::=	ASC		{: RESULT = getFactory().createNodeOrder(Order.ASC); :}
		|	DESC	{: RESULT = getFactory().createNodeOrder(Order.DESC); :}
		;
		
Expression	::=	AndCondition:c					{: RESULT = c; :}
			|	Expression:e OR AndCondition:c
				{:
					RESULT = getFactory().createNodeOperator(Operator.OR);
					RESULT.addChild(e);
					RESULT.addChild(c);
				:}
         	;
         	
AndCondition	::=	Condition:c						{: RESULT = c; :}
				|	AndCondition:e AND Condition:c
					{:
						RESULT = getFactory().createNodeOperator(Operator.AND);
						RESULT.addChild(e);
						RESULT.addChild(c);
					:}
         		;
         		
Condition	::=	Operand:o	{: RESULT = o; :}
			|	Operand:o1 Compare:cmp Operand:o2
				{:
					RESULT = cmp;
					cmp.addChild(o1);
					cmp.addChild(o2);
				:}
			|	NOT Expression:e	{: RESULT = getFactory().createNodeNot(); RESULT.addChild(e); :}
			|	OPEN_PARENTHESIS Expression:e CLOSE_PARENTHESIS	{: RESULT = e; :}
			;
			
/* enum Operator { NOT_EQ, EQUAL, ... } */
Compare	::=	NOT_EQ			{: RESULT = getFactory().createNodeOperator(Operator.NOT_EQ); :}
		|	EQUAL			{: RESULT = getFactory().createNodeOperator(Operator.EQUAL); :}
		|	LESS_OR_EQ		{: RESULT = getFactory().createNodeOperator(Operator.LESS_OR_EQ); :}
		|	GREATER_OR_EQ	{: RESULT = getFactory().createNodeOperator(Operator.GREATER_OR_EQ); :}
		|	LESS			{: RESULT = getFactory().createNodeOperator(Operator.LESS); :}
		|	GREATER			{: RESULT = getFactory().createNodeOperator(Operator.GREATER); :}
		;
		
Operand	::=	Summand:s					{: RESULT = s; :}
		|	Operand:o CONCAT Summand:s	{: RESULT = getFactory().createNodeConcat(o, s); :}
		;
		
Summand	::=	Factor:f					{: RESULT = f; :}
		|	Summand:s PLUS Factor:f		{: RESULT = getFactory().createNodePlus(s, f); :}
		|	Summand:s MINUS Factor:f	{: RESULT = getFactory().createNodeMinus(s, f); :}
		;

Factor	::=	Term:t					{: RESULT = t; :}
		|	Factor:f MULT Term:t	{: RESULT = getFactory().createNodeMult(f, t); :}	
		|	Factor:f DIV Term:t		{: RESULT = getFactory().createNodeDiv(f, t); :}
		;
		
Term	::= Value:v		{: RESULT = v; :}
		|	Column:c	{: RESULT = c; :}
		;

Set		::= SET Column:c EQUAL Value:v	{: RESULT = getFactory().createNodeSet(c, v); :}
		;

Datas	::= Data:d				{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(d); :}
     	|	Datas:ds SEP Data:d	{: RESULT = ds; ds.getChildren().add(d);
     	;

Data	::=	Column:c Type:t NullOpt:e	{: RESULT = getFactory().createNodeData(c, t, e); :}
    	;

/* enum Type {INT, VARCHAR} */
Type 	::= INT	{: RESULT = getFactory().createNodeType(Type.INT); :}
		| VARCHAR OPEN_PARENTHESIS NUMBER:n CLOSE_PARENTHESIS	{: RESULT = getFactory().createNodeType(Type.VARCHAR, n); :}
		;

NullOpt	::=
		|	NotOpt:n NULL
		{:
			if (n == null) {
				RESULT = getFactory().createNodeNull();
			} else {
				RESULT = n;
				n.getChildren().add(getFactory().createNodeNull());
			}
		:}
		;

NotOpt	::=
		|	NOT	{: RESULT = getFactory().createNodeNot(); :}
		;


Values	::= Value:v		{: RESULT = getFactory().createNodeBlock(); RESULT.getChildren().add(v); :}
		|	Values:vs SEP Value:v	{: RESULT = vs; vs.getChildren().add(v); :}
		;
		
Value	::= TEXT:t		{: RESULT = getFactory().createNodeText(t); :}
		|	Numeric:n	{: RESULT = n; :}
		|	TRUE		{: RESULT = getFactory().createNodeBoolean(true); :}
		|	FALSE		{: RESULT = getFactory().createNodeBoolean(false); :}
		|	NULL		{: RESULT = getFactory().createNodeNull(); :}
		;
		
Numeric	::=	UminusOpt:m NUMBER:n
			{:
				if (m == null) {
					RESULT = getFactory().createNodeNumber(n);
				} else {
					RESULT = getFactory().createNodeNumber(-n);
				}
			:}
		|	UminusOpt:m NUMBER:n1 DOT NUMBER:n2
			{:
				/* todo */
			:}
		;

UminusOpt	::=	
			|	MINUS	{: RESULT = getFactory().createNodeUminus(); :}
			;

PrimaryKeyOpt	::= 
				|	SEP PRIMARY KEY OPEN_PARENTHESIS Column:n CLOSE_PARENTHESIS
					{:
						RESULT = getFactory().createPrimaryKey(n);
					:}
				;
